? number ?

error := func message: nil:
	print("Error: ", message, 10);
	finish();
end;

number := func byte: n:
	n := {
		$byte := byte,
		$nextbyte := nil
	};
end,

list_to_number := func l: n:
	if !l.$root then
		n := number(0);
		exit;
	end

	cur_l := l.$root,
	root_n := number(cur_l.$data), 
	cur_n := root_n;
	loop
		cur_l := cur_l.$next;
		if !cur_l then exit; end
		n := number(cur_l.$data);
		cur_n.$nextbyte := n;
		cur_n := cur_n.$nextbyte;
	end
	n := root_n;
end,

ncopy := func x: n:
	n := number(0);
	cur := n;
	loop
		cur.$byte := x.$byte;
		x := x.$nextbyte;
		if !x then
			exit;
		else
			cur.$nextbyte := number(0);
			cur := cur.$nextbyte;
		end
	end
end,

its0 := func { n : !n.$byte && !n.$nextbyte },

reverse := func n: head:
	prev := nil, cur := n, head := cur;
	loop
		if cur then
			next := cur.$nextbyte;
			cur.$nextbyte := prev;
			head := cur,
			prev := cur,
			cur := next;
		else
			exit;
		end
	end
end;

? Comparissions ?

recur_gt := func x, y: z:
	? This needs the numbers to be big-endian ?
	if !x then
		z := 0;
	else
		if !y then
			z := 1;
		else
			if x.$byte == y.$byte then
				z := recur_gt(x.$nextbyte, y.$nextbyte);
			else
				if x.$byte > y.$byte then
					z := 1;
				else
					z := 0;
				end
			end
		end
	end
end,

gt := func x, y: z:
	z := recur_gt(reverse(x), reverse(y));
end;

? Arithmetic Algorithms ?

recur_add := func x, y, count: nil:
	if count then
		recur_add(x, number(count), 0);
		count := 0;
	end

	if !y then
		exit;
	end

	if (255 - y.$byte < x.$byte) then
		count := 1;
	end
	x.$byte := x.$byte + y.$byte;

	if x.$nextbyte == nil then
		x.$nextbyte := number(count);
		count := 0;
	end
	recur_add(x.$nextbyte, y.$nextbyte, count);
end,

add := func x, y: n:
	n := ncopy(x);
	recur_add(n, y, 0);
end;

recur_sub := func x, y, count: nil:
	if count then
		recur_sub(x, number(count), 0);
		count := 0;
	end

	if !y then
		exit;
	end
	if !x then
		error("substracting y from x where y > x");
	end

	if y.$byte > x.$byte then
		count := 1;
	end
	x.$byte := x.$byte - y.$byte;

	recur_sub(x.$nextbyte, y.$nextbyte, count);

	if x.$nextbyte then
		? eliminates the last 0's ?
		if x.$nextbyte.$byte == 0 && x.$nextbyte.$nextbyte == nil then
			x.$nextbyte := nil;
		end
	end
end,

sub := func x, y: n:
	n := ncopy(x);
	recur_sub(n, y, 0);
end;

mul := func x, y: n:
	n := number(0), y := ncopy(y);
	loop
		if its0(y) then
			exit;
		else
			recur_add(n, x, 0);
			recur_sub(y, number(1), 0);
		end
	end
end,

div := func x, y: x:

end,

mod := func x, y: x:

end;

? Other ?

prnum := func n: nil:
	cur := n;
	print("Number: ", 10);
	loop
		if !cur then exit; end
		present(cur.$byte);
		cur := cur.$nextbyte;
	end
end;

? Module Export ?

$module := {
	number := number,
	list_number := list_to_number,
	ncopy := ncopy,
	add := add,
	sub := sub,
	mul := mul,
	reverse := reverse,
	prnum := prnum
};

